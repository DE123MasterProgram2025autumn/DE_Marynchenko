---
title: "Лабораторна робота №2: Інтеграція та об’єднання даних з різних джерел"
author: "Valeriia Marynchenko, date: `r Sys.Date()`" 
output: 
    html: 
        highlight: tango 
        toc: yes
    html_notebook:
        toc: yes # генерація змісту документу 
        toc_float: true 
        highlight: tango # Колір підсвічування коду 
fontsize: 12pt # розмір шрифту 
header-includes:
 \usepackage[T2A]{fontenc}
 \usepackage[utf8]{inputenc}
 \usepackage[russian]{babel}
editor_options: 
    chunk_output_type: console
editor: 
    markdown: 
         wrap: sentence
---

### Мета роботи

Освоїти повний цикл інтеграції реляційних даних у середовищі R: від завантаження даних з різноманітних джерел (CSV, Excel, Google Таблиці) до їх об’єднання за допомогою вертикальних (`bind_rows`) та горизонтальних (`left_join`, `semi_join`, `anti_join`) операцій. Навчитися будувати реалістичні ETL-конвеєри, які моделюють типові задачі інженера даних у production-середовищі.

### Що ви будете вміти після виконання роботи?

Що ви будете вміти після виконання роботи?

* Завантажувати великі текстові файли (CSV/TSV) швидко та ефективно за допомогою vroom.

* Імпортувати дані з Excel-файлів, включаючи роботу з кількома аркушами, за допомогою `readxl`.

* Підключатися до Google Таблиць через API і імпортувати дані з них.

* Об’єднувати кілька файлів одного формату у єдиний датафрейм.

* Виконувати агрегації данихза допомогою вертикальних (`bind_rows`), горизонтальних (`left_join`) обєднань для збагачення даних інформацією з інших таблиць.

* Використовувати фільтруючі з’єднання (`semi_join`, `anti_join`) для аналізу перетинів та відмінностей між наборами даних.

* Моделювати реальні бізнес-сценарії (наприклад, розрахунок зарплати) у функціональному стилі з використанням `dplyr`, `tidyr`, `stringr`.

## Вступ

Дані, потрібні для аналітики, рідко знаходяться в одному джерелі, в одному форматі і не завжди є впорядкованими. Навпаки — часто вони розподілені між різними системами: локальними файлами, корпоративними електронними таблицями, хмарними сервісами, базами даних. Тому ключова компетенція інженера даних — це здатність надійно інтегрувати ці джерела у єдину, аналітично придатну структуру.

Ця лабораторна робота моделює типовий ETL-процес (Extract, Transform, Load):

* __Extract__ — ви завантажите дані з різних джерел:

 + текстові файли через vroom (оптимізований для швидкості та пам’яті)

 + Excel-аркуші через readxl (без залежності від Java)

 + Google Таблиці через googlesheets4 (з правильною OAuth-авторизацією).

* __Transform__ — ви об’єднаєте ці дані за допомогою:

 + вертикального злиття (`bind_rows`) для агрегації щомісячних звітів

 + горизонтального злиття (`left_join`) для додавання бонусів, штрафів, інформації про відділи

 + фільтруючих з’єднань (`semi_join`, `anti_join`) для відповіді на конкретні бізнес-питання.

* __Load__ — ви отримаєте готовий аналітичний датафрейм, який можна використовувати для звітування, візуалізації або подальшої обробки.

В якості прикладу пропонується реалістичний сценарій розрахунку зарплати, де дані розподілені між аркушами Excel: основні ставки, бонуси, штрафи та довідник відділів. Це ідеальна ілюстрація того, як інженери даних перетворюють розрізнені джерела на цінну інформацію.

Ці навички є фундаментом для побудови масштабованих, повторюваних конвеєрів обробки даних — саме тих, які використовуються в сучасних data-проєктах.

## Робоче завдання

- Опрацювати [приклад 1](lab2_DE_2022_part1.R) та [приклад 2](lab2_DE_2022__part2.R)

```{r}
?read.csv()
# І Імпорт даних з TSV, CSV, Excel файлов и Google Таблиц -----------------

# Зазавантаження даних у R
# ІНсталяція пакетів
# install.packages("vroom")
```



```{r}
# install.packages("readxl")
# install.packages("devtools")
devtools::install_github("tidyverse/googlesheets4", force = TRUE)

# ###########################################
# підключення пакетів

packages <- c("vroom", "readxl", "devtools", "vroom")

lapply(packages, library, character.only = TRUE)

library("vroom")


# ###########################################
# Читання CSV, TSV та інших  текстових файлів
getwd()

## читання локальних файлів
ga_data <- vroom(file = "data/ga_nowember.csv", delim = "/t")
ga_data <- vroom(file = "data/ga_nowember.csv")
ga_data_2 <- vroom(file = "data/ga_december.csv")


## читання файлів, опублікованих в інтернеті
ga_data_i <- vroom("https://raw.githubusercontent.com/selesnow/publications/master/data_example/russian_text_in_r/ga_nowember.csv")

## читання декількох файлів в одну таблицю
files <- dir(path = "data", pattern = "\\data/.csv$")
ga_full <- vroom(files, delim = "\t")

View(ga_full)


# ###########################################
# Читання Excel файлів
library(readxl)

## отримати список листів з Excel файлу
excel_sheets("data/ga_examples.xlsx")

## зчитати дані з листа
xl_dec <- read_excel("data/ga_examples.xlsx", sheet = "dec")


# ###########################################
# Читання Google Таблиць
library(googlesheets4)


# Актуальний синтаксис див. тут: https://googlesheets4.tidyverse.org/reference/index.html#section-auth

## Авторизація НЕПРАВИЛЬНА!
##sheets_auth(email = "vlerkalerka@gmail.com")
#sheets_find()

# ПРАВИЛЬНА
gs4_auth(email = "vlerkalerka@gmail.com")
gs4_deauth()
gs4_find()

## Підключення до доксу
ss_id <- as_sheets_id("1xu_beKZVpJJTHTvAab_vN3ZiMB03BytKArGjJUO8cck")
ss_id <- as_sheets_id("1ucz62sENkrkSEzMNXFVdQbIVHB0ZQw66")

# альтернативний варіант
read_sheet("https://docs.google.com/spreadsheets/d/1U6Cf_qEOhiR9AZqTqS3mbMF3zt2db48ZP5v3rkrAEJY/edit?gid=780868077#gid=780868077")

## відкрити докс у браузері
gs4_browse(ss_id)

## подивитися список листів
sheet_names(ss_id)

## отримати дані з листа

gs_ga_data <- sheets_read(ss = ss_id, 
                          sheet = "dec")

## отримати дані з діапазона на листі
gs_ga_data <- sheets_read(ss = ss, 
                          sheet = "dec", 
                          range = "A1:C10")
```

- Виконати [Індивідуальне завдання](#варіанти-індивідуальних-завдань)\

- Код розмістити нижче:

```{r}

# Тут має бути Ваш код

```

### Варіанти індивідуальних завдань

::: callout-note

Примітка.

*Варіанти вибираються по колу, відштовхуючись від номера студента у списку групи.*

:::

Виконайте наступні завдання, використовуючи конвеєрний підхід (`%>%` або `|>`) та функції пакета `dplyr`. Кожен пункт має бути реалізований одним конвеєром (ланцюжком) без проміжного збереження в змінні (якщо не вказано інше).

### Варіант 1

Датасети згенерувати самостійно.

### **Тема: Аналіз продажів за два квартали**

Ви отримали два Excel-файли з даними про продажі компанії:

- `sales_q1.xlsx` — містить аркуші:

 - `products` — довідник товарів (`product_id`, `product_name`, `category`)

 - `sales_jan`, `sales_feb`, `sales_mar` — щомісячні продажі (`order_id`, `product_id`, `quantity`, `price_per_unit`, `customer_id`)

- `sales_q2.xlsx` — аналогічна структура для квітня, травня, червня.

Крім того, є окремий файл `customers.csv` з інформацією про клієнтів:

`customer_id`, `region`, `customer_type` (B2B / B2C).

---

### Завдання:

1. **Завантаження даних**

 - Завантажте обидва Excel-файли, прочитайте всі аркуші з продажами.

 - Завантажте `customers.csv` за допомогою `vroom`.
 
```{r}

sales_q1 <- lapply(
  c("sales_jan", "sales_feb", "sales_mar"),
  function(sheet_name) {
    read_excel(path = "data/sales_q1.xlsx", sheet = sheet_name)
  }
)
    
sales_q2 <- lapply(
  c("sales_apr", "sales_may", "sales_jun"),
  function(sheet_name) {
    read_excel(path = "data/sales_q2.xlsx", sheet = sheet_name)
  }
)
customers <- vroom("data/customers.csv")
```
2. **Вертикальне об’єднання**

 - Об’єднайте всі 6 таблиць продажів (`jan`–`jun`) у єдину таблицю `all_sales`.

 - Додайте стовпець `month` з назвою місяця (наприклад, `"2024-01"`).
```{r}

library(dplyr)
library(purrr)

all_sales <- c(
    # Присвоюємо імена елементам списків
    sales_q1 %>% set_names(c("sales_jan", "sales_feb", "sales_mar")),
    sales_q2 %>% set_names(c("sales_apr", "sales_may", "sales_jun"))
  ) |>
  # Об'єднуємо всі таблиці, створюючи стовпець "month" з імен списків
  dplyr::bind_rows(.id = "month") |>
  # Перетворюємо назви місяців
  dplyr::mutate(
    month = dplyr::case_match(month, 
      "sales_jan" ~ "2025-01",
      "sales_feb" ~ "2025-02",
      "sales_mar" ~ "2025-03",
      "sales_apr" ~ "2025-04",
      "sales_may" ~ "2025-05",
      "sales_jun" ~ "2025-06",
      .default = month
    )
  )

```
 
 
3. **Горизонтальне об’єднання**

 - Додайте до `all_sales` інформацію про товари (`product_name`, `category`) через `left_join`.

 - Додайте інформацію про клієнтів (`region`, `customer_type`) через `left_join`.
```{r}
products_q1 <- read_excel("data/sales_q1.xlsx", sheet = "products")
all_sales_joined <- all_sales |>
  dplyr::left_join(products_q1, by = "product_id") |>
  dplyr::left_join(customers, by = "customer_id") |>
  dplyr::relocate(product_name, category, .after = product_id) |>
  dplyr::relocate(region, customer_type, .after = customer_id)

print(all_sales_joined)

```

4. **Агрегація та аналіз**

 - Розрахуйте загальний дохід: `revenue = quantity * price_per_unit`.

 - Для кожного місяця та регіону обчисліть:

 - загальний дохід,

 - кількість унікальних клієнтів,

 - середній чек (`revenue / кількість замовлень`).
 
```{r}
analysis_results <- all_sales_joined |>
  dplyr::mutate(revenue = quantity * price_per_unit) |>
  dplyr::group_by(month, region) |>
  dplyr::summarise(
    total_revenue = sum(revenue),
    unique_customers = dplyr::n_distinct(customer_id),
    total_orders = dplyr::n_distinct(order_id),
    average_check = total_revenue / total_orders,
    .groups = "drop"
  ) |>
  dplyr::rename_with(~ paste0("total_", .), total_revenue) |>
  dplyr::rename_with(~ paste0("avg_", .), average_check)

print(analysis_results)
```

5. **Фільтруюче з’єднання**

 - Визначте `customer_id`, які робили покупки **і в Q1, і в Q2** (використайте `semi_join`).

```{r}
q1_customers <- all_sales |> 
    dplyr::filter(month %in% c("2025-01", "2025-02", "2025-03")) |>
    dplyr::select(customer_id) |>
    dplyr::distinct()

q2_customers <- all_sales |> 
    dplyr::filter(month %in% c("2025-04", "2025-05", "2025-06")) |>
    dplyr::select(customer_id) |>
    dplyr::distinct()

customers_q1_and_q2 <- q1_customers |>
  dplyr::semi_join(q2_customers, by = "customer_id")

print(customers_q1_and_q2)
```
 - Визначте клієнтів, які **зникли після Q1** (були в Q1, але не в Q2) — використайте `anti_join`.
 
```{r}
customers_disappeared_after_q1 <- q1_customers |>
  #in q1_customers BUT NOT in q2_customers
  dplyr::anti_join(q2_customers, by = "customer_id")

print(customers_disappeared_after_q1)
```
---

### Технічні вимоги:

- Використовуйте **конвеєрний синтаксис** (`%>%` або `|>`).

- Не створюйте проміжні змінні без необхідності.

- Використовуйте `across()`, `rename_with()`, `relocate()` для чистоти коду.

- Усі дії мають бути **відтворювані** (файли завантажуються з папки `data/`).


------------------------------------------------------------------------

```{=html}

<hr style="border: 1px solid #ddd; margin: 30px 0 10px 0;">

<footer style="text-align: center; font-size: 0.9em; color: #666; padding: 15px; background: #f9f9f9; border-top: 1px solid #eee; margin-top: 20px;">

<p><strong>Виконав(ла): Ваше ПІБ</strong> | Група: <strong>Ваша група</strong> | Викладач: Сидоренко В.М.</p>

<p>Кременчуцький національний університет імені Михайла Остроградського &copy; 2025</p>

</footer>

```
